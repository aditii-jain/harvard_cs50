# Lode Runner
#### Video Demo:  <https://youtu.be/2GH2_iUtvKA>
#### Description: Lode Runner is a 2D puzzle-platform game, developed by Douglas E. Smith and published by Broderbund in 1983. Its game-play mechanics are similar to Space Panic from 1980. The player controls a character who must collect all the gold pieces in a level and get to the end while being chased by a number of enemies. If the player succeeds, a new level is unlocked. Each level is made up of multiple stories that can be reached with ladders. Coming in contact with guards causes the player to lose one of his five lives and restart the level.

Elements of the game:
- player: the player is you - you can control it using keystrokes such as, up, down, left and right
- enemy: the enemy follows the player around until it touches them, resulting in a lost life or ultimately, the end of the game in which stage you will be taken back to the main menu.

Other actors of the game include:
- bars: the player and enemy can slide on these horizontal monkey bars to either go to a ladder or platform 
- bricks/walls: the player and enemy run on these blue bricks 
- gold: each gold coin is worth 250 points and can be located anywhere on the game canvas. The goal of the player is to collect all the available coins to go onto the next level. Each level has a random number of these coins, each placed in a strategically challenging location. 
- ladders: the player and enemy can make use of these ladders to go up or down on the game canvas. Going a little too right or too left can throw the player off the ladder and result in falling down onto the platform.
- and text objects to bring some definition to the game

Worlds:
The worlds are responsible for what appears on the screen. 
- LevelWorld is a subclass of World and is responsible for loading levels or restarting the level when a life is lost. It has a child class called MyLevelWorld that updates the super class' score, level and lives. It detects the loss of a live (when it teaches an enemy) or touching objects of the gold class. The most import job of this subclass (MyLevelWorld) is to handle the display by updating the score, lives and level on the heads up display. LevelWorld has a default constructor that loads the default level (level 1). This is an important class because it keeps track of the lives, score and level at a top level. If this class didn't exist, it would be impossible to remember the level, lives and score because every time a life is lost or a new level is made, a new instance of MyLevelWorld is created and it loses information of the previous instance. Using the keyword super on these variables gives it access and memory of these variables. 

- MyLevelWorld is a subclass of LevelWorld that has an act method to detect coming in contact with object of the gold class or the enemy. In the act method, it asks the player if it is touching gold every frame and adds to the score if that's the case. Then it has an if condition to check if it is. touching the enemy which too, it asks the player because only the player has information whether or not it is touching things. Within this if condition, it checks if the lives are zero, if that's true, gameOver text is displayed and it tells its parent class that the game is over, waits a few frames (using a counter) and then redirects the user back to main menu where they can restart the game if desired. If it turns out that there are still lives left, then the same level with zero score and one less life is loaded. It uses a method of the Actor class (getObjects()) to get all the gold objects into a list. If the size of the list at any point is zero, that indicates that all gold is collected and the user can proceed to the next level or be redirected back to the main menu if they were at the final level. The final job of this subclass is to update the heads up display that it does using update methods. These methods essentially just set the image of these text objects to the updated score, lives or level. 

- MainMenu is another subclass of World. It is pretty simple, consisting of a start button and a running player for decoration purposes. Its act method just animates a player running back and forth using transition of images to give it that running motion. The start button is just another subclass of Actor that has its own act method to detect being clicked on by the user - in which case it will start the game by loading an instance of MyLevelWorld by calling on the default constructor that essentially just loads level 1 with 5 lives. The start button also shrinks and grows, and darkens and lightens respectively to provide a beautified click. It also plays a click sound as a cherry on top.

Actors:
- The Person class which is a subclass of Actor has two subclass - the enemy and the player. The enemy class uses some basic AI to chase the player around. The person class a getCommand() method that is overridden by both the enemy and the player. It returns to the person class one of four:  "up", "down", "left", or "right". These two subclasses also have a getPerson() method that return what type of person they are - enemy or player. Based on what they return, there are two different animations because they are two different colors, meaning they will have different images. The enemy is also slightly slower than the player except on the ladders. The enemy class has four methods: playerAbove(), playerBelow(), playerToLeft() and playerToRight(). These methods compare the x and y coordinates of these two people and decides whether the enemy returns up, down, left, or right. For example, if the player is above and to the right, the player keeps going right until it encounters a ladder, in which case, it will go up the ladder. There are a few glitches because of some gaps in between some of these objects but mostly, it works alright. There is also a subclass of Player that I just executed for fun. It is a mousePlayer, which is basically a player but the means through which it gets commands is the location of the mouse, kind of like the enemy that gets commands with respect to the player's position. 

- Actors that have their own class but do not have any of their own functionality: bar, brick, BlueRect(rectangle for heads up display), Gold, Ladder.

One major design choice I made was making a parent class for all the people in the game, called Person. It was responsible for all the functional movement, but it got commands from the rest of it's sub classes through the getCommand() method that I simply overrode in the subclasses. This choice was really transformative because I no longer had to copy paste all of the code in all the subclasses. This made my code compositely more modular.
